<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>EA4 MoritzBergan</title>
    <link rel="stylesheet" href="styles.css" />
    <link
      rel="stylesheet"
      href="https://use.fontawesome.com/releases/v5.14.0/css/all.css"
      integrity="sha384-HzLeBuhoNPvSl5KYnjx0BT+WB0QEEqLprO+NBkkk5gbc67FTaL7XIGa2w1L0Xbgc"
      crossorigin="anonymous"/>
  </head>

  <body>
    <!-- Navbar Section -->
    <nav class="navbar">
      <div class="navbar__container">
        <a href="#home" id="navbar__logo"><img src="media/MUTZE_M.png" alt="MUTZE" style="width:50px"></a>
        <div class="navbar__toggle" id="mobile-menu">
          <span class="bar"></span>
          <span class="bar"></span>
          <span class="bar"></span>
        </div>
        <ul class="navbar__menu">
        </ul>
      </div>
    </nav>

    <!-- Hero Section -->
    <div class="hero" id="home">
      <center><h1>Parametrisierte Fl√§chen</h1></center>
      <div class="hero__container">
        <canvas id="canvas" width="500" height="500"></canvas>

        <script>

            // Get the WebGL context.
            var canvas = document.getElementById('canvas');
            var gl = canvas.getContext('experimental-webgl');

            // Pipeline setup.
            gl.clearColor(0, 0, 0, 0.1);

            // Backface culling.
            gl.frontFace(gl.CCW);
            gl.enable(gl.CULL_FACE);
            gl.cullFace(gl.BACK);

            // Depth(Z)-Buffer.
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);    

            // Polygon offset of rastered Fragments.
            gl.enable(gl.POLYGON_OFFSET_FILL);
            gl.polygonOffset(0.5, 0);        

            // Compile vertex shader. 
            var vsSource = '' + 
                'attribute vec3 pos;' + 
                'attribute vec4 col;' + 
                'varying vec4 color;' + 
                'void main(){' + 'color = col;' + 
                'gl_Position = vec4(pos, 1);' +
                '}';
            var vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, vsSource);
            gl.compileShader(vs);

            // Compile fragment shader.
            fsSouce = 'precision mediump float;' + 
                'varying vec4 color;' + 
                'void main() {' + 
                'gl_FragColor = color;' + 
                '}';
            var fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, fsSouce);
            gl.compileShader(fs);

            // Link shader together into a program.
            var prog = gl.createProgram();
            gl.attachShader(prog, vs);
            gl.attachShader(prog, fs);
            gl.bindAttribLocation(prog, 0, "pos");
            gl.linkProgram(prog);
            gl.useProgram(prog);

            // Vertex data.
            // Positions, Index data.
            var vertices, indicesLines, indicesTris;

            // Fill the data arrays.
            createVertexData();

            // Setup position vertex buffer object.
            var vboPos = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
            gl.bufferData(gl.ARRAY_BUFFER,
                vertices, gl.STATIC_DRAW);

            // Bind vertex buffer to attribute variable.
            var posAttrib = gl.getAttribLocation(prog, 'pos');
            gl.vertexAttribPointer(posAttrib, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(posAttrib);

            // Setup constant color.
            var colAttrib = gl.getAttribLocation(prog, 'col');

            // Setup lines index buffer object.
            var iboLines = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboLines);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indicesLines, gl.STATIC_DRAW);
            iboLines.numberOfElements = indicesLines.length;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            // Setup tris index buffer object.
            var iboTris = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboTris);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indicesTris, gl.STATIC_DRAW);
            iboTris.numberOfElements = indicesTris.length;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            // Clear framebuffer and render primitives.
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Setup rendering tris.
            gl.vertexAttrib4f(colAttrib, 1, 0.3, 0.3, 1);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboTris);
            gl.drawElements(gl.TRIANGLES, iboTris.numberOfElements, gl.UNSIGNED_SHORT, 0);

            // Setup rendering lines.
            gl.vertexAttrib4f(colAttrib, 1, 1, 1, 1);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboLines);
            gl.drawElements(gl.LINES, iboLines.numberOfElements, gl.UNSIGNED_SHORT, 0);

            function createVertexData(){
                var n = 32;
                var m = 32;

                // Positions.
                vertices = new Float32Array(3 * (n+1) * (m+1));

                // Index data.
                indicesLines = new Uint16Array(2 * 2 * n * m);
                indicesTris  = new Uint16Array(3 * 2 * n * m);

                const rangeU = {min: (0), max: (2*Math.PI)};
                const rangeV = {min: (0), max: (2*Math.PI)};

                var du = (rangeU.max-rangeU.min)/n;
                var dv = (rangeU.max-rangeU.min)/m;
                var c = 1;

                // Counter for entries in index array.
                var iLines = 0;
                var iTris = 0;

                // Loop angle u.
                for(var i=0, u=-Math.PI; i <= n; i++, u += du) {

                    // Loop height v.
                    for(var j=0, v=0; j <= m; j++, v += dv) {
                        var iVertex = i*(m+1) + j;

                        var x = c * Math.cos(v)*Math.cos(u);
                        var y = c * Math.sin(v)*Math.cos(u);
                        var z = c * Math.sin(u);

                        // Set vertex positions.
                        //vertices[iVertex * 13] = x;
                        vertices[iVertex * 3] = x;
                        vertices[iVertex * 3 + 1] = y;
                        vertices[iVertex * 3 + 2] = z;

                        // Set index.
                        // Line on beam.
                        if(j>0 && i>0){
                            indicesLines[iLines++] = iVertex - 1;
                            indicesLines[iLines++] = iVertex;
                         }

                        // Line on ring.
                        if(j>0 && i>0){
                            indicesLines[iLines++] = iVertex - (m+1);                            
                            indicesLines[iLines++] = iVertex;
                        }

                        // Set index.
                        // Two Triangles.
                        if(j>0 && i>0){
                            indicesTris[iTris++] = iVertex;
                            indicesTris[iTris++] = iVertex - 1;
                            indicesTris[iTris++] = iVertex - (m+1);
                           
                            indicesTris[iTris++] = iVertex - 1;
                            indicesTris[iTris++] = iVertex - (m+1) - 1;                            
                            indicesTris[iTris++] = iVertex - (m+1);                          
                        }
                    }
                }
            }
        </script>
      </div>
    </div>

    <script src="app.js"></script>
  </body>
</html>